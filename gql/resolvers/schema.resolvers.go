package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.41

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/3dw1nM0535/uzi-api/gql"
	"github.com/3dw1nM0535/uzi-api/gql/model"
	"github.com/3dw1nM0535/uzi-api/internal/logger"
	"github.com/3dw1nM0535/uzi-api/services/location"
	t "github.com/3dw1nM0535/uzi-api/services/trip"
	"github.com/3dw1nM0535/uzi-api/store/sqlc"
	"github.com/google/uuid"
)

// CreateCourierDocument is the resolver for the createCourierDocument field.
func (r *mutationResolver) CreateCourierDocument(ctx context.Context, input model.CourierUploadInput) (bool, error) {
	courierID := getCourierIDFromResolverContext(ctx, r)

	err := r.CreateCourierUpload(input.Type.String(), input.URI, courierID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// TrackCourierGps is the resolver for the trackCourierGps field.
func (r *mutationResolver) TrackCourierGps(ctx context.Context, input model.GpsInput) (bool, error) {
	userID := stringToUUID(ctx.Value("userID").(string))

	go r.TrackCourierLocation(userID, input)
	return true, nil
}

// SetCourierStatus is the resolver for the setCourierStatus field.
func (r *mutationResolver) SetCourierStatus(ctx context.Context, status string) (bool, error) {
	userID := stringToUUID(ctx.Value("userID").(string))

	s := model.CourierStatus(status)
	return r.UpdateCourierStatus(userID, s)
}

// CreateTrip is the resolver for the createTrip field.
func (r *mutationResolver) CreateTrip(ctx context.Context, input model.CreateTripInput) (*model.Trip, error) {
	r.mutex.Lock()
	defer r.mutex.Unlock()

	userID := stringToUUID(ctx.Value("userID").(string))

	params := sqlc.CreateTripParams{
		UserID:        userID,
		ProductID:     stringToUUID(input.TripProductID),
		StartLocation: fmt.Sprintf("SRID=4326;POINT(%.8f %.8f)", input.TripInput.Pickup.Location.Lat, input.TripInput.Pickup.Location.Lng),
		EndLocation:   fmt.Sprintf("SRID=4326;POINT(%.8f %.8f)", input.TripInput.Dropoff.Location.Lat, input.TripInput.Dropoff.Location.Lng),
	}

	trip, err := r.tripService.CreateTrip(params)
	tripUpdate := model.TripUpdate{ID: trip.ID}

	timeoutCtx, cancel := context.WithTimeout(context.Background(), time.Minute*5)
	go func() {
		logger.Logger.Infoln("Goroutine started...")
		defer cancel()

		for {
			select {
			case <-timeoutCtx.Done():
				tripUpdate.Status = model.TripStatusCourierNotFound
				u, marshalErr := json.Marshal(tripUpdate)
				if marshalErr != nil {
					logger.Logger.Errorf(marshalErr.Error())
					logger.Logger.Infoln("Goroutine exiting due to error...")
					return
				}

				notFoundErr := r.redisClient.Publish(context.Background(), t.TRIP_UPDATES, u).Err()
				if notFoundErr != nil {
					logger.Logger.Errorf(notFoundErr.Error())
					logger.Logger.Infoln("Goroutine exiting due to error...")
					return
				}
				logger.Logger.Infoln("Goroutine exiting")

				return
			default:
				courier, err := r.tripService.FindAvailableCourier(*input.TripInput.Pickup.Location)
				if err != nil {
					logger.Logger.Errorf(err.Error())
					logger.Logger.Infoln("Goroutine exiting due to error...")
					return
				}
				logger.Logger.Infoln("Starting...")

				if courier != nil {
					logger.Logger.Infoln("Publishing found...")
					tripUpdate.Status = model.TripStatusCourierFound
					u, marshalErr := json.Marshal(tripUpdate)
					if marshalErr != nil {
						logger.Logger.Errorf(marshalErr.Error())
						return
					}

					foundErr := r.redisClient.Publish(context.Background(), t.TRIP_UPDATES, u).Err()
					if foundErr != nil {
						logger.Logger.Errorf(foundErr.Error())
						return
					}

					err := r.tripService.AssignTripToCourier(trip.ID, courier.ID)
					if err != nil {
						logger.Logger.Errorf(err.Error())
						return
					} else {
						logger.Logger.Infoln("Courier assigned...")
						logger.Logger.Infoln("Publishing arriving...")
						tripUpdate.Status = model.TripStatusCourierArriving
						u, marshalErr = json.Marshal(tripUpdate)
						if marshalErr != nil {
							logger.Logger.Errorf(marshalErr.Error())
							return
						}

						arrivingErr := r.redisClient.Publish(context.Background(), t.TRIP_UPDATES, u).Err()
						if arrivingErr != nil {
							logger.Logger.Errorf(arrivingErr.Error())
							return
						}
					}
					logger.Logger.Infoln("Goroutine exiting due to courier found...")
					return
				}
			}
		}
	}()

	return trip, err
}

// Hello is the resolver for the hello field.
func (r *queryResolver) Hello(ctx context.Context) (string, error) {
	return "Hello, world!", nil
}

// GetCourierDocuments is the resolver for the getCourierDocuments field.
func (r *queryResolver) GetCourierDocuments(ctx context.Context) ([]*model.Uploads, error) {
	courierID := getCourierIDFromResolverContext(ctx, r)

	uploads, err := r.GetCourierUploads(courierID)
	if err != nil {
		return nil, err
	}

	return uploads, nil
}

// SearchPlace is the resolver for the searchPlace field.
func (r *queryResolver) SearchPlace(ctx context.Context, textQuery string) ([]*model.Place, error) {
	return r.AutocompletePlace(textQuery)
}

// ReverseGeocode is the resolver for the reverseGeocode field.
func (r *queryResolver) ReverseGeocode(ctx context.Context, place model.GpsInput) (*location.Geocode, error) {
	return r.GeocodeLatLng(place)
}

// GetRoute is the resolver for the getRoute field.
func (r *queryResolver) ComputeTripRoute(ctx context.Context, input model.TripRouteInput) (*model.TripRoute, error) {
	return r.routeService.ComputeTripRoute(input)
}

// GetCourierNearPickupPoint is the resolver for the getCourierNearPickupPoint field.
func (r *queryResolver) GetCourierNearPickupPoint(ctx context.Context, point model.GpsInput) ([]*model.Courier, error) {
	return r.tripService.GetCourierNearPickupPoint(point)
}

// TripUpdates is the resolver for the tripUpdates field.
func (r *subscriptionResolver) TripUpdates(ctx context.Context, tripID uuid.UUID) (<-chan *model.TripUpdate, error) {
	pubsub := r.redisClient.Subscribe(ctx, t.TRIP_UPDATES)

	ch := make(chan *model.TripUpdate)

	go func() {
		for {
			msg, err := pubsub.ReceiveMessage(ctx)
			if err != nil {
				close(ch)
				return
			}
			var update *model.TripUpdate
			fmt.Println(msg.Payload)
			if err := json.Unmarshal([]byte(msg.Payload), &update); err != nil {
				return
			}
			fmt.Println(update)
			if update.ID == tripID {
				ch <- update
			}
		}
	}()

	return ch, nil
}

// Mutation returns gql.MutationResolver implementation.
func (r *Resolver) Mutation() gql.MutationResolver { return &mutationResolver{r} }

// Query returns gql.QueryResolver implementation.
func (r *Resolver) Query() gql.QueryResolver { return &queryResolver{r} }

// Subscription returns gql.SubscriptionResolver implementation.
func (r *Resolver) Subscription() gql.SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
