// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: query.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const assignCourierToTrip = `-- name: AssignCourierToTrip :one
UPDATE couriers
SET trip_id = $1
WHERE id = $2
RETURNING id, verified, status, location, ratings, points, user_id, product_id, trip_id, created_at, updated_at
`

type AssignCourierToTripParams struct {
	TripID uuid.NullUUID `json:"trip_id"`
	ID     uuid.UUID     `json:"id"`
}

func (q *Queries) AssignCourierToTrip(ctx context.Context, arg AssignCourierToTripParams) (Courier, error) {
	row := q.db.QueryRowContext(ctx, assignCourierToTrip, arg.TripID, arg.ID)
	var i Courier
	err := row.Scan(
		&i.ID,
		&i.Verified,
		&i.Status,
		&i.Location,
		&i.Ratings,
		&i.Points,
		&i.UserID,
		&i.ProductID,
		&i.TripID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const assignTripToCourier = `-- name: AssignTripToCourier :one
UPDATE trips
SET courier_id = $1
WHERE id = $2
RETURNING id, start_location, end_location, confirmed_pickup, courier_id, user_id, product_id, cost, status, created_at, updated_at
`

type AssignTripToCourierParams struct {
	CourierID uuid.NullUUID `json:"courier_id"`
	ID        uuid.UUID     `json:"id"`
}

func (q *Queries) AssignTripToCourier(ctx context.Context, arg AssignTripToCourierParams) (Trip, error) {
	row := q.db.QueryRowContext(ctx, assignTripToCourier, arg.CourierID, arg.ID)
	var i Trip
	err := row.Scan(
		&i.ID,
		&i.StartLocation,
		&i.EndLocation,
		&i.ConfirmedPickup,
		&i.CourierID,
		&i.UserID,
		&i.ProductID,
		&i.Cost,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createCourier = `-- name: CreateCourier :one
INSERT INTO couriers (
  user_id
) VALUES (
  $1
)
RETURNING id, verified, status, location, ratings, points, user_id, product_id, trip_id, created_at, updated_at
`

func (q *Queries) CreateCourier(ctx context.Context, userID uuid.NullUUID) (Courier, error) {
	row := q.db.QueryRowContext(ctx, createCourier, userID)
	var i Courier
	err := row.Scan(
		&i.ID,
		&i.Verified,
		&i.Status,
		&i.Location,
		&i.Ratings,
		&i.Points,
		&i.UserID,
		&i.ProductID,
		&i.TripID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createCourierUpload = `-- name: CreateCourierUpload :one
INSERT INTO uploads (
  type, uri, courier_id, verification
) VALUES (
  $1, $2, $3, $4
)
RETURNING id, type, uri, verification, courier_id, user_id, created_at, updated_at
`

type CreateCourierUploadParams struct {
	Type         string        `json:"type"`
	Uri          string        `json:"uri"`
	CourierID    uuid.NullUUID `json:"courier_id"`
	Verification string        `json:"verification"`
}

func (q *Queries) CreateCourierUpload(ctx context.Context, arg CreateCourierUploadParams) (Upload, error) {
	row := q.db.QueryRowContext(ctx, createCourierUpload,
		arg.Type,
		arg.Uri,
		arg.CourierID,
		arg.Verification,
	)
	var i Upload
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Uri,
		&i.Verification,
		&i.CourierID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createRecipient = `-- name: CreateRecipient :one
INSERT INTO recipients (
  name, building, unit, phone, trip_id, trip_note
) VALUES (
  $1, $2, $3, $4, $5, $6
)
RETURNING id, name, building, unit, phone, trip_note, trip_id, created_at, updated_at
`

type CreateRecipientParams struct {
	Name     string         `json:"name"`
	Building sql.NullString `json:"building"`
	Unit     sql.NullString `json:"unit"`
	Phone    string         `json:"phone"`
	TripID   uuid.NullUUID  `json:"trip_id"`
	TripNote string         `json:"trip_note"`
}

func (q *Queries) CreateRecipient(ctx context.Context, arg CreateRecipientParams) (Recipient, error) {
	row := q.db.QueryRowContext(ctx, createRecipient,
		arg.Name,
		arg.Building,
		arg.Unit,
		arg.Phone,
		arg.TripID,
		arg.TripNote,
	)
	var i Recipient
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Building,
		&i.Unit,
		&i.Phone,
		&i.TripNote,
		&i.TripID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (
  id, ip, user_agent, phone
) VALUES (
  $1, $2, $3, $4
)
RETURNING id, ip, user_agent, phone, created_at, updated_at
`

type CreateSessionParams struct {
	ID        uuid.UUID `json:"id"`
	Ip        string    `json:"ip"`
	UserAgent string    `json:"user_agent"`
	Phone     string    `json:"phone"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRowContext(ctx, createSession,
		arg.ID,
		arg.Ip,
		arg.UserAgent,
		arg.Phone,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.Ip,
		&i.UserAgent,
		&i.Phone,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTrip = `-- name: CreateTrip :one
INSERT INTO trips (
  user_id, product_id, confirmed_pickup, start_location, end_location
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id, start_location, end_location, confirmed_pickup, courier_id, user_id, product_id, cost, status, created_at, updated_at
`

type CreateTripParams struct {
	UserID          uuid.UUID   `json:"user_id"`
	ProductID       uuid.UUID   `json:"product_id"`
	ConfirmedPickup interface{} `json:"confirmed_pickup"`
	StartLocation   interface{} `json:"start_location"`
	EndLocation     interface{} `json:"end_location"`
}

func (q *Queries) CreateTrip(ctx context.Context, arg CreateTripParams) (Trip, error) {
	row := q.db.QueryRowContext(ctx, createTrip,
		arg.UserID,
		arg.ProductID,
		arg.ConfirmedPickup,
		arg.StartLocation,
		arg.EndLocation,
	)
	var i Trip
	err := row.Scan(
		&i.ID,
		&i.StartLocation,
		&i.EndLocation,
		&i.ConfirmedPickup,
		&i.CourierID,
		&i.UserID,
		&i.ProductID,
		&i.Cost,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTripCost = `-- name: CreateTripCost :one
UPDATE trips
SET cost = $1
WHERE id = $2
RETURNING id, start_location, end_location, confirmed_pickup, courier_id, user_id, product_id, cost, status, created_at, updated_at
`

type CreateTripCostParams struct {
	Cost int32     `json:"cost"`
	ID   uuid.UUID `json:"id"`
}

func (q *Queries) CreateTripCost(ctx context.Context, arg CreateTripCostParams) (Trip, error) {
	row := q.db.QueryRowContext(ctx, createTripCost, arg.Cost, arg.ID)
	var i Trip
	err := row.Scan(
		&i.ID,
		&i.StartLocation,
		&i.EndLocation,
		&i.ConfirmedPickup,
		&i.CourierID,
		&i.UserID,
		&i.ProductID,
		&i.Cost,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
  first_name, last_name, phone
) VALUES (
  $1, $2, $3
)
RETURNING id, first_name, last_name, phone, onboarding, created_at, updated_at
`

type CreateUserParams struct {
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
	Phone     string `json:"phone"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.FirstName, arg.LastName, arg.Phone)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Phone,
		&i.Onboarding,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserUpload = `-- name: CreateUserUpload :one
INSERT INTO uploads (
  type, uri, user_id
) VALUES (
  $1, $2, $3
)
RETURNING id, type, uri, verification, courier_id, user_id, created_at, updated_at
`

type CreateUserUploadParams struct {
	Type   string        `json:"type"`
	Uri    string        `json:"uri"`
	UserID uuid.NullUUID `json:"user_id"`
}

func (q *Queries) CreateUserUpload(ctx context.Context, arg CreateUserUploadParams) (Upload, error) {
	row := q.db.QueryRowContext(ctx, createUserUpload, arg.Type, arg.Uri, arg.UserID)
	var i Upload
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Uri,
		&i.Verification,
		&i.CourierID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findAvailableCourier = `-- name: FindAvailableCourier :one
SELECT id, user_id, product_id, ST_AsGeoJSON(location) AS location FROM
couriers
WHERE ST_DWithin(location, $1::geography, $2) AND status = 'ONLINE' AND verified = 'true' AND trip_id IS null
LIMIT 1
`

type FindAvailableCourierParams struct {
	Point  interface{} `json:"point"`
	Radius interface{} `json:"radius"`
}

type FindAvailableCourierRow struct {
	ID        uuid.UUID     `json:"id"`
	UserID    uuid.NullUUID `json:"user_id"`
	ProductID uuid.NullUUID `json:"product_id"`
	Location  interface{}   `json:"location"`
}

func (q *Queries) FindAvailableCourier(ctx context.Context, arg FindAvailableCourierParams) (FindAvailableCourierRow, error) {
	row := q.db.QueryRowContext(ctx, findAvailableCourier, arg.Point, arg.Radius)
	var i FindAvailableCourierRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProductID,
		&i.Location,
	)
	return i, err
}

const findByPhone = `-- name: FindByPhone :one
SELECT id, first_name, last_name, phone, onboarding, created_at, updated_at FROM users
WHERE phone = $1
LIMIT 1
`

func (q *Queries) FindByPhone(ctx context.Context, phone string) (User, error) {
	row := q.db.QueryRowContext(ctx, findByPhone, phone)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Phone,
		&i.Onboarding,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findUserByID = `-- name: FindUserByID :one
SELECT id, first_name, last_name, phone, onboarding, created_at, updated_at FROM users
WHERE id = $1
LIMIT 1
`

func (q *Queries) FindUserByID(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, findUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Phone,
		&i.Onboarding,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCourierAssignedTrip = `-- name: GetCourierAssignedTrip :one
SELECT id, verified, status, location, ratings, points, user_id, product_id, trip_id, created_at, updated_at FROM couriers
WHERE id = $1 AND trip_id = null
LIMIT 1
`

func (q *Queries) GetCourierAssignedTrip(ctx context.Context, id uuid.UUID) (Courier, error) {
	row := q.db.QueryRowContext(ctx, getCourierAssignedTrip, id)
	var i Courier
	err := row.Scan(
		&i.ID,
		&i.Verified,
		&i.Status,
		&i.Location,
		&i.Ratings,
		&i.Points,
		&i.UserID,
		&i.ProductID,
		&i.TripID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCourierAvatar = `-- name: GetCourierAvatar :one
SELECT id, uri FROM uploads
WHERE courier_id = $1 AND type = 'DP'
`

type GetCourierAvatarRow struct {
	ID  uuid.UUID `json:"id"`
	Uri string    `json:"uri"`
}

func (q *Queries) GetCourierAvatar(ctx context.Context, courierID uuid.NullUUID) (GetCourierAvatarRow, error) {
	row := q.db.QueryRowContext(ctx, getCourierAvatar, courierID)
	var i GetCourierAvatarRow
	err := row.Scan(&i.ID, &i.Uri)
	return i, err
}

const getCourierByID = `-- name: GetCourierByID :one
SELECT id, trip_id, product_id, user_id, ST_AsGeoJSON(location) AS location FROM
couriers
WHERE id = $1
LIMIT 1
`

type GetCourierByIDRow struct {
	ID        uuid.UUID     `json:"id"`
	TripID    uuid.NullUUID `json:"trip_id"`
	ProductID uuid.NullUUID `json:"product_id"`
	UserID    uuid.NullUUID `json:"user_id"`
	Location  interface{}   `json:"location"`
}

func (q *Queries) GetCourierByID(ctx context.Context, id uuid.UUID) (GetCourierByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getCourierByID, id)
	var i GetCourierByIDRow
	err := row.Scan(
		&i.ID,
		&i.TripID,
		&i.ProductID,
		&i.UserID,
		&i.Location,
	)
	return i, err
}

const getCourierByUserID = `-- name: GetCourierByUserID :one
SELECT id, user_id, product_id, ST_AsGeoJSON(location) AS location FROM
couriers
WHERE user_id = $1
LIMIT 1
`

type GetCourierByUserIDRow struct {
	ID        uuid.UUID     `json:"id"`
	UserID    uuid.NullUUID `json:"user_id"`
	ProductID uuid.NullUUID `json:"product_id"`
	Location  interface{}   `json:"location"`
}

func (q *Queries) GetCourierByUserID(ctx context.Context, userID uuid.NullUUID) (GetCourierByUserIDRow, error) {
	row := q.db.QueryRowContext(ctx, getCourierByUserID, userID)
	var i GetCourierByUserIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProductID,
		&i.Location,
	)
	return i, err
}

const getCourierLocation = `-- name: GetCourierLocation :one
SELECT ST_AsGeoJSON(location) AS location FROM
couriers
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetCourierLocation(ctx context.Context, id uuid.UUID) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getCourierLocation, id)
	var location interface{}
	err := row.Scan(&location)
	return location, err
}

const getCourierNearPickupPoint = `-- name: GetCourierNearPickupPoint :many
SELECT id, product_id, ST_AsGeoJSON(location) AS location FROM
couriers
WHERE ST_DWithin(location, $1::geography, $2) AND status = 'ONLINE' AND verified = 'true'
`

type GetCourierNearPickupPointParams struct {
	Point  interface{} `json:"point"`
	Radius interface{} `json:"radius"`
}

type GetCourierNearPickupPointRow struct {
	ID        uuid.UUID     `json:"id"`
	ProductID uuid.NullUUID `json:"product_id"`
	Location  interface{}   `json:"location"`
}

func (q *Queries) GetCourierNearPickupPoint(ctx context.Context, arg GetCourierNearPickupPointParams) ([]GetCourierNearPickupPointRow, error) {
	rows, err := q.db.QueryContext(ctx, getCourierNearPickupPoint, arg.Point, arg.Radius)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCourierNearPickupPointRow{}
	for rows.Next() {
		var i GetCourierNearPickupPointRow
		if err := rows.Scan(&i.ID, &i.ProductID, &i.Location); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCourierStatus = `-- name: GetCourierStatus :one
SELECT status FROM
couriers
WHERE user_id = $1
LIMIT 1
`

func (q *Queries) GetCourierStatus(ctx context.Context, userID uuid.NullUUID) (string, error) {
	row := q.db.QueryRowContext(ctx, getCourierStatus, userID)
	var status string
	err := row.Scan(&status)
	return status, err
}

const getCourierTrip = `-- name: GetCourierTrip :one
SELECT id, start_location, end_location, confirmed_pickup, courier_id, user_id, product_id, cost, status, created_at, updated_at FROM trips
WHERE courier_id = $1
LIMIT 1
`

func (q *Queries) GetCourierTrip(ctx context.Context, courierID uuid.NullUUID) (Trip, error) {
	row := q.db.QueryRowContext(ctx, getCourierTrip, courierID)
	var i Trip
	err := row.Scan(
		&i.ID,
		&i.StartLocation,
		&i.EndLocation,
		&i.ConfirmedPickup,
		&i.CourierID,
		&i.UserID,
		&i.ProductID,
		&i.Cost,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCourierUpload = `-- name: GetCourierUpload :one
SELECT id, type, uri, verification, courier_id, user_id, created_at, updated_at FROM
uploads
WHERE courier_id = $1 AND type = $2
LIMIT 1
`

type GetCourierUploadParams struct {
	CourierID uuid.NullUUID `json:"courier_id"`
	Type      string        `json:"type"`
}

func (q *Queries) GetCourierUpload(ctx context.Context, arg GetCourierUploadParams) (Upload, error) {
	row := q.db.QueryRowContext(ctx, getCourierUpload, arg.CourierID, arg.Type)
	var i Upload
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Uri,
		&i.Verification,
		&i.CourierID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCourierUploads = `-- name: GetCourierUploads :many
SELECT id, type, uri, verification, courier_id, user_id, created_at, updated_at FROM uploads
WHERE courier_id = $1
`

func (q *Queries) GetCourierUploads(ctx context.Context, courierID uuid.NullUUID) ([]Upload, error) {
	rows, err := q.db.QueryContext(ctx, getCourierUploads, courierID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Upload{}
	for rows.Next() {
		var i Upload
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Uri,
			&i.Verification,
			&i.CourierID,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNearbyAvailableCourierProducts = `-- name: GetNearbyAvailableCourierProducts :many
SELECT c.id, c.product_id, p.id, p.name, p.description, p.weight_class, p.icon, p.relevance, p.created_at, p.updated_at FROM couriers c
JOIN products p
ON ST_DWithin(c.location, $1::geography, $2)
WHERE c.product_id = p.id AND c.verified = 'true'
ORDER BY p.relevance ASC
`

type GetNearbyAvailableCourierProductsParams struct {
	Point  interface{} `json:"point"`
	Radius interface{} `json:"radius"`
}

type GetNearbyAvailableCourierProductsRow struct {
	ID          uuid.UUID     `json:"id"`
	ProductID   uuid.NullUUID `json:"product_id"`
	ID_2        uuid.UUID     `json:"id_2"`
	Name        string        `json:"name"`
	Description string        `json:"description"`
	WeightClass int32         `json:"weight_class"`
	Icon        string        `json:"icon"`
	Relevance   int32         `json:"relevance"`
	CreatedAt   time.Time     `json:"created_at"`
	UpdatedAt   time.Time     `json:"updated_at"`
}

func (q *Queries) GetNearbyAvailableCourierProducts(ctx context.Context, arg GetNearbyAvailableCourierProductsParams) ([]GetNearbyAvailableCourierProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, getNearbyAvailableCourierProducts, arg.Point, arg.Radius)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetNearbyAvailableCourierProductsRow{}
	for rows.Next() {
		var i GetNearbyAvailableCourierProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ID_2,
			&i.Name,
			&i.Description,
			&i.WeightClass,
			&i.Icon,
			&i.Relevance,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductByID = `-- name: GetProductByID :one
SELECT id, icon, name, weight_class FROM products
WHERE id = $1
LIMIT 1
`

type GetProductByIDRow struct {
	ID          uuid.UUID `json:"id"`
	Icon        string    `json:"icon"`
	Name        string    `json:"name"`
	WeightClass int32     `json:"weight_class"`
}

func (q *Queries) GetProductByID(ctx context.Context, id uuid.UUID) (GetProductByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getProductByID, id)
	var i GetProductByIDRow
	err := row.Scan(
		&i.ID,
		&i.Icon,
		&i.Name,
		&i.WeightClass,
	)
	return i, err
}

const getSession = `-- name: GetSession :one
SELECT id, ip, user_agent, phone, created_at, updated_at FROM sessions
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetSession(ctx context.Context, id uuid.UUID) (Session, error) {
	row := q.db.QueryRowContext(ctx, getSession, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.Ip,
		&i.UserAgent,
		&i.Phone,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTrip = `-- name: GetTrip :one
SELECT id, status, courier_id, cost, product_id, ST_AsGeoJSON(confirmed_pickup) AS confirmed_pickup, ST_AsGeoJSON(start_location) AS start_location, ST_AsGeoJSON(end_location) AS end_location FROM trips
WHERE id = $1
LIMIT 1
`

type GetTripRow struct {
	ID              uuid.UUID     `json:"id"`
	Status          string        `json:"status"`
	CourierID       uuid.NullUUID `json:"courier_id"`
	Cost            int32         `json:"cost"`
	ProductID       uuid.UUID     `json:"product_id"`
	ConfirmedPickup interface{}   `json:"confirmed_pickup"`
	StartLocation   interface{}   `json:"start_location"`
	EndLocation     interface{}   `json:"end_location"`
}

func (q *Queries) GetTrip(ctx context.Context, id uuid.UUID) (GetTripRow, error) {
	row := q.db.QueryRowContext(ctx, getTrip, id)
	var i GetTripRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.CourierID,
		&i.Cost,
		&i.ProductID,
		&i.ConfirmedPickup,
		&i.StartLocation,
		&i.EndLocation,
	)
	return i, err
}

const getTripRecipient = `-- name: GetTripRecipient :one
SELECT id, name, building, unit, phone, trip_note, trip_id, created_at, updated_at FROM recipients
WHERE trip_id = $1
LIMIT 1
`

func (q *Queries) GetTripRecipient(ctx context.Context, tripID uuid.NullUUID) (Recipient, error) {
	row := q.db.QueryRowContext(ctx, getTripRecipient, tripID)
	var i Recipient
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Building,
		&i.Unit,
		&i.Phone,
		&i.TripNote,
		&i.TripID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserUpload = `-- name: GetUserUpload :one
SELECT id, type, uri, verification, courier_id, user_id, created_at, updated_at FROM uploads
WHERE user_id = $1 AND type = $2
LIMIT 1
`

type GetUserUploadParams struct {
	UserID uuid.NullUUID `json:"user_id"`
	Type   string        `json:"type"`
}

func (q *Queries) GetUserUpload(ctx context.Context, arg GetUserUploadParams) (Upload, error) {
	row := q.db.QueryRowContext(ctx, getUserUpload, arg.UserID, arg.Type)
	var i Upload
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Uri,
		&i.Verification,
		&i.CourierID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const isCourier = `-- name: IsCourier :one
SELECT verified FROM
couriers
WHERE user_id = $1
LIMIT 1
`

func (q *Queries) IsCourier(ctx context.Context, userID uuid.NullUUID) (sql.NullBool, error) {
	row := q.db.QueryRowContext(ctx, isCourier, userID)
	var verified sql.NullBool
	err := row.Scan(&verified)
	return verified, err
}

const isUserOnboarding = `-- name: IsUserOnboarding :one
SELECT onboarding FROM
users
WHERE id = $1
LIMIT 1
`

func (q *Queries) IsUserOnboarding(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, isUserOnboarding, id)
	var onboarding bool
	err := row.Scan(&onboarding)
	return onboarding, err
}

const setCourierStatus = `-- name: SetCourierStatus :one
UPDATE couriers
SET status = $1
WHERE user_id = $2
RETURNING id, verified, status, location, ratings, points, user_id, product_id, trip_id, created_at, updated_at
`

type SetCourierStatusParams struct {
	Status string        `json:"status"`
	UserID uuid.NullUUID `json:"user_id"`
}

func (q *Queries) SetCourierStatus(ctx context.Context, arg SetCourierStatusParams) (Courier, error) {
	row := q.db.QueryRowContext(ctx, setCourierStatus, arg.Status, arg.UserID)
	var i Courier
	err := row.Scan(
		&i.ID,
		&i.Verified,
		&i.Status,
		&i.Location,
		&i.Ratings,
		&i.Points,
		&i.UserID,
		&i.ProductID,
		&i.TripID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const setOnboardingStatus = `-- name: SetOnboardingStatus :one
UPDATE users
SET onboarding = $1
WHERE phone = $2
RETURNING id, first_name, last_name, phone, onboarding, created_at, updated_at
`

type SetOnboardingStatusParams struct {
	Onboarding bool   `json:"onboarding"`
	Phone      string `json:"phone"`
}

func (q *Queries) SetOnboardingStatus(ctx context.Context, arg SetOnboardingStatusParams) (User, error) {
	row := q.db.QueryRowContext(ctx, setOnboardingStatus, arg.Onboarding, arg.Phone)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Phone,
		&i.Onboarding,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const setTripStatus = `-- name: SetTripStatus :one
UPDATE trips
SET status = $1
WHERE id = $2
RETURNING id, start_location, end_location, confirmed_pickup, courier_id, user_id, product_id, cost, status, created_at, updated_at
`

type SetTripStatusParams struct {
	Status string    `json:"status"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) SetTripStatus(ctx context.Context, arg SetTripStatusParams) (Trip, error) {
	row := q.db.QueryRowContext(ctx, setTripStatus, arg.Status, arg.ID)
	var i Trip
	err := row.Scan(
		&i.ID,
		&i.StartLocation,
		&i.EndLocation,
		&i.ConfirmedPickup,
		&i.CourierID,
		&i.UserID,
		&i.ProductID,
		&i.Cost,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const trackCourierLocation = `-- name: TrackCourierLocation :one
UPDATE couriers
SET location = $2
WHERE user_id = $1
RETURNING id, verified, status, location, ratings, points, user_id, product_id, trip_id, created_at, updated_at
`

type TrackCourierLocationParams struct {
	UserID   uuid.NullUUID `json:"user_id"`
	Location interface{}   `json:"location"`
}

func (q *Queries) TrackCourierLocation(ctx context.Context, arg TrackCourierLocationParams) (Courier, error) {
	row := q.db.QueryRowContext(ctx, trackCourierLocation, arg.UserID, arg.Location)
	var i Courier
	err := row.Scan(
		&i.ID,
		&i.Verified,
		&i.Status,
		&i.Location,
		&i.Ratings,
		&i.Points,
		&i.UserID,
		&i.ProductID,
		&i.TripID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const unassignCourierTrip = `-- name: UnassignCourierTrip :one
UPDATE couriers
SET trip_id = null
WHERE id = $1
RETURNING id, verified, status, location, ratings, points, user_id, product_id, trip_id, created_at, updated_at
`

func (q *Queries) UnassignCourierTrip(ctx context.Context, id uuid.UUID) (Courier, error) {
	row := q.db.QueryRowContext(ctx, unassignCourierTrip, id)
	var i Courier
	err := row.Scan(
		&i.ID,
		&i.Verified,
		&i.Status,
		&i.Location,
		&i.Ratings,
		&i.Points,
		&i.UserID,
		&i.ProductID,
		&i.TripID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUpload = `-- name: UpdateUpload :one
UPDATE uploads
SET uri = COALESCE($2, uri), verification = COALESCE($3, verification)
WHERE id = $1
RETURNING id, type, uri, verification, courier_id, user_id, created_at, updated_at
`

type UpdateUploadParams struct {
	ID           uuid.UUID      `json:"id"`
	Uri          sql.NullString `json:"uri"`
	Verification sql.NullString `json:"verification"`
}

func (q *Queries) UpdateUpload(ctx context.Context, arg UpdateUploadParams) (Upload, error) {
	row := q.db.QueryRowContext(ctx, updateUpload, arg.ID, arg.Uri, arg.Verification)
	var i Upload
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Uri,
		&i.Verification,
		&i.CourierID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserName = `-- name: UpdateUserName :one
UPDATE users
SET first_name = COALESCE($1, first_name), last_name = COALESCE($2, last_name)
WHERE phone = $3
RETURNING id, first_name, last_name, phone, onboarding, created_at, updated_at
`

type UpdateUserNameParams struct {
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
	Phone     string `json:"phone"`
}

func (q *Queries) UpdateUserName(ctx context.Context, arg UpdateUserNameParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUserName, arg.FirstName, arg.LastName, arg.Phone)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Phone,
		&i.Onboarding,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
